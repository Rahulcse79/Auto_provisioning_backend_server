_dfeâ€.x([["parseXmlDeclaration",()=>parseXmlDeclaration],["parseAttrs",()=>parseAttrs],["decodeEntities",()=>decodeEntities],["encodeEntities",()=>encodeEntities],["parseXml",()=>parseXml]]);/**
 * Copyright 2013-2019  GenieACS Inc.
 *
 * This file is part of GenieACS.
 *
 * GenieACS is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * GenieACS is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with GenieACS.  If not, see <http://www.gnu.org/licenses/>.
 */
const CHAR_SINGLE_QUOTE = 39;
const CHAR_DOUBLE_QUOTE = 34;
const CHAR_LESS_THAN = 60;
const CHAR_GREATER_THAN = 62;
const CHAR_COLON = 58;
const CHAR_SPACE = 32;
const CHAR_TAB = 9;
const CHAR_CR = 13;
const CHAR_LF = 10;
const CHAR_SLASH = 47;
const CHAR_EXMARK = 33;
const CHAR_QMARK = 63;
const CHAR_EQUAL = 61;
const STATE_LESS_THAN = 1;
const STATE_SINGLE_QUOTE = 2;
const STATE_DOUBLE_QUOTE = 3;
       function parseXmlDeclaration(buffer) {
    const encodings = ["utf16le", "utf8", "latin1", "ascii"];
    for (const enc of encodings) {
        let str = buffer.toString(enc, 0, 150);
        if (str.startsWith("<?xml")) {
            str = str.slice(0, str.indexOf("?>"));
            try {
                return parseAttrs(str.slice(5));
            }
            catch (err) {
                // Ignore
            }
        }
    }
    return null;
}
       function parseAttrs(string) {
    const attrs = [];
    const len = string.length;
    let state = 0;
    let name = "";
    let namespace = "";
    let localName = "";
    let idx = 0;
    let colonIdx = 0;
    for (let i = 0; i < len; ++i) {
        const c = string.charCodeAt(i);
        switch (c) {
            case CHAR_SINGLE_QUOTE:
            case CHAR_DOUBLE_QUOTE:
                if (state === c) {
                    state = 0;
                    if (name) {
                        const value = string.slice(idx + 1, i);
                        const e = {
                            name: name,
                            namespace: namespace,
                            localName: localName,
                            value: value,
                        };
                        attrs.push(e);
                        name = "";
                        idx = i + 1;
                    }
                }
                else {
                    state = c;
                    idx = i;
                }
                continue;
            case CHAR_COLON:
                if (state)
                    continue;
                if (idx >= colonIdx)
                    colonIdx = i;
                continue;
            case CHAR_EQUAL:
                if (state)
                    continue;
                if (name)
                    throw new Error(`Unexpected character at ${i}`);
                name = string.slice(idx, i).trim();
                // TODO validate name
                if (colonIdx > idx) {
                    namespace = string.slice(idx, colonIdx).trim();
                    localName = string.slice(colonIdx + 1, i).trim();
                }
                else {
                    namespace = "";
                    localName = name;
                }
        }
    }
    if (name)
        throw new Error(`Attribute must have value at ${idx}`);
    const tail = string.slice(idx);
    if (tail.trim())
        throw new Error(`Unexpected string at ${len - tail.length}`);
    return attrs;
}
       function decodeEntities(string) {
    return string.replace(/&[0-9a-z#]+;/gi, (match) => {
        switch (match) {
            case "&quot;":
                return '"';
            case "&amp;":
                return "&";
            case "&apos;":
                return "'";
            case "&lt;":
                return "<";
            case "&gt;":
                return ">";
            default:
                if (match.startsWith("&#x")) {
                    const str = match.slice(3, -1).toLowerCase();
                    const n = parseInt(str, 16);
                    if (str.endsWith(n.toString(16)))
                        return String.fromCharCode(n);
                }
                else if (match.startsWith("&#")) {
                    const str = match.slice(2, -1);
                    const n = parseInt(str);
                    if (str.endsWith(n.toString()))
                        return String.fromCharCode(n);
                }
        }
        return match;
    });
}
       function encodeEntities(string) {
    const entities = {
        "&": "&amp;",
        '"': "&quot;",
        "'": "&apos;",
        "<": "&lt;",
        ">": "&gt;",
    };
    return string.replace(/[&"'<>]/g, (m) => entities[m]);
}
       function parseXml(string) {
    const len = string.length;
    let state1 = 0;
    let state1Index = 0;
    let state2 = 0;
    let state2Index = 0;
    const root = {
        name: "root",
        namespace: "",
        localName: "root",
        attrs: "",
        text: "",
        bodyIndex: 0,
        children: [],
    };
    const stack = [root];
    for (let i = 0; i < len; ++i) {
        switch (string.charCodeAt(i)) {
            case CHAR_SINGLE_QUOTE:
                switch (state1 & 0xff) {
                    case STATE_SINGLE_QUOTE:
                        state1 = state2;
                        state1Index = state2Index;
                        state2 = 0;
                        continue;
                    case STATE_LESS_THAN:
                        state2 = state1;
                        state2Index = state1Index;
                        state1 = STATE_SINGLE_QUOTE;
                        state1Index = i;
                        continue;
                }
                continue;
            case CHAR_DOUBLE_QUOTE:
                switch (state1 & 0xff) {
                    case STATE_DOUBLE_QUOTE:
                        state1 = state2;
                        state1Index = state2Index;
                        state2 = 0;
                        continue;
                    case STATE_LESS_THAN:
                        state2 = state1;
                        state2Index = state1Index;
                        state1 = STATE_DOUBLE_QUOTE;
                        state1Index = i;
                        continue;
                }
                continue;
            case CHAR_LESS_THAN:
                if ((state1 & 0xff) === 0) {
                    state2 = state1;
                    state2Index = state1Index;
                    state1 = STATE_LESS_THAN;
                    state1Index = i;
                }
                continue;
            case CHAR_COLON:
                if ((state1 & 0xff) === STATE_LESS_THAN) {
                    const colonIndex = (state1 >> 8) & 0xff;
                    if (colonIndex === 0)
                        state1 ^= ((i - state1Index) & 0xff) << 8;
                }
                continue;
            case CHAR_SPACE:
            case CHAR_TAB:
            case CHAR_CR:
            case CHAR_LF:
                if ((state1 & 0xff) === STATE_LESS_THAN) {
                    const wsIndex = (state1 >> 16) & 0xff;
                    if (wsIndex === 0)
                        state1 ^= ((i - state1Index) & 0xff) << 16;
                }
                continue;
            case CHAR_GREATER_THAN:
                if ((state1 & 0xff) === STATE_LESS_THAN) {
                    const secondChar = string.charCodeAt(state1Index + 1);
                    const wsIndex = (state1 >> 16) & 0xff;
                    let name, colonIndex, e, parent, selfClosing, localName, namespace;
                    switch (secondChar) {
                        case CHAR_SLASH:
                            e = stack.pop();
                            name =
                                wsIndex === 0
                                    ? string.slice(state1Index + 2, i)
                                    : string.slice(state1Index + 2, state1Index + wsIndex);
                            if (e.name !== name)
                                throw new Error(`Unmatched closing tag at ${i}`);
                            if (!e.children.length)
                                e.text = string.slice(e.bodyIndex, state1Index);
                            state1 = state2;
                            state1Index = state2Index;
                            state2 = 0;
                            continue;
                        case CHAR_EXMARK:
                            if (string.startsWith("![CDATA[", state1Index + 1)) {
                                if (string.endsWith("]]", i))
                                    throw new Error(`CDATA nodes are not supported at ${i}`);
                            }
                            else if (string.startsWith("!--", state1Index + 1)) {
                                // Comment node, ignore
                                if (string.endsWith("--", i)) {
                                    state1 = state2;
                                    state1Index = state2Index;
                                    state2 = 0;
                                }
                            }
                            continue;
                        case CHAR_QMARK:
                            if (string.charCodeAt(i - 1) === CHAR_QMARK) {
                                // XML declaration node, ignore
                                state1 = state2;
                                state1Index = state2Index;
                                state2 = 0;
                            }
                            continue;
                        default:
                            selfClosing = +(string.charCodeAt(i - 1) === CHAR_SLASH);
                            parent = stack[stack.length - 1];
                            colonIndex = (state1 >> 8) & 0xff;
                            name =
                                wsIndex === 0
                                    ? string.slice(state1Index + 1, i - selfClosing)
                                    : string.slice(state1Index + 1, state1Index + wsIndex);
                            if (colonIndex && (!wsIndex || colonIndex < wsIndex)) {
                                localName = name.slice(colonIndex);
                                namespace = name.slice(0, colonIndex - 1);
                            }
                            else {
                                localName = name;
                                namespace = "";
                            }
                            e = {
                                name: name,
                                namespace: namespace,
                                localName: localName,
                                attrs: wsIndex
                                    ? string.slice(state1Index + wsIndex + 1, i - selfClosing)
                                    : "",
                                text: "",
                                bodyIndex: i + 1,
                                children: [],
                            };
                            parent.children.push(e);
                            if (!selfClosing)
                                stack.push(e);
                            state1 = state2;
                            state1Index = state2Index;
                            state2 = 0;
                            continue;
                    }
                }
                continue;
        }
    }
    if (state1)
        throw new Error(`Unclosed token at ${state1Index}`);
    if (stack.length > 1) {
        const e = stack[stack.length - 1];
        throw new Error(`Unclosed XML element at ${e.bodyIndex}`);
    }
    if (!root.children.length)
        root.text = string;
    return root;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL2hvbWUvY29yYWwvRG9jdW1lbnRzL0dpdEh1Yi9hY3Mtc2VydmVyL2xpYi94bWwtcGFyc2VyLnRzIiwic291cmNlcyI6WyIvaG9tZS9jb3JhbC9Eb2N1bWVudHMvR2l0SHViL2Fjcy1zZXJ2ZXIvbGliL3htbC1wYXJzZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBaUJHO0FBRUgsTUFBTSxpQkFBaUIsR0FBRyxFQUFFLENBQUM7QUFDN0IsTUFBTSxpQkFBaUIsR0FBRyxFQUFFLENBQUM7QUFDN0IsTUFBTSxjQUFjLEdBQUcsRUFBRSxDQUFDO0FBQzFCLE1BQU0saUJBQWlCLEdBQUcsRUFBRSxDQUFDO0FBQzdCLE1BQU0sVUFBVSxHQUFHLEVBQUUsQ0FBQztBQUN0QixNQUFNLFVBQVUsR0FBRyxFQUFFLENBQUM7QUFDdEIsTUFBTSxRQUFRLEdBQUcsQ0FBQyxDQUFDO0FBQ25CLE1BQU0sT0FBTyxHQUFHLEVBQUUsQ0FBQztBQUNuQixNQUFNLE9BQU8sR0FBRyxFQUFFLENBQUM7QUFDbkIsTUFBTSxVQUFVLEdBQUcsRUFBRSxDQUFDO0FBQ3RCLE1BQU0sV0FBVyxHQUFHLEVBQUUsQ0FBQztBQUN2QixNQUFNLFVBQVUsR0FBRyxFQUFFLENBQUM7QUFDdEIsTUFBTSxVQUFVLEdBQUcsRUFBRSxDQUFDO0FBRXRCLE1BQU0sZUFBZSxHQUFHLENBQUMsQ0FBQztBQUMxQixNQUFNLGtCQUFrQixHQUFHLENBQUMsQ0FBQztBQUM3QixNQUFNLGtCQUFrQixHQUFHLENBQUMsQ0FBQztBQW1CN0IsTUFBTSxVQUFVLG1CQUFtQixDQUFDLE1BQWM7SUFDaEQsTUFBTSxTQUFTLEdBQXFCLENBQUMsU0FBUyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDM0UsS0FBSyxNQUFNLEdBQUcsSUFBSSxTQUFTLEVBQUU7UUFDM0IsSUFBSSxHQUFHLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUs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QUMsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDO0tBQzNEO0lBRUQsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTTtRQUFFLElBQUksQ0FBQyxJQUFJLEdBQUcsTUFBTSxDQUFDO0lBQzlDLE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxOSAgR2VuaWVBQ1MgSW5jLlxuICpcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIEdlbmllQUNTLlxuICpcbiAqIEdlbmllQUNTIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEFmZmVybyBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzXG4gKiBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGVcbiAqIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4gKlxuICogR2VuaWVBQ1MgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gKiBHTlUgQWZmZXJvIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgQWZmZXJvIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAqIGFsb25nIHdpdGggR2VuaWVBQ1MuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4gKi9cblxuY29uc3QgQ0hBUl9TSU5HTEVfUVVPVEUgPSAzOTtcbmNvbnN0IENIQVJfRE9VQkxFX1FVT1RFID0gMzQ7XG5jb25zdCBDSEFSX0xFU1NfVEhBTiA9IDYwO1xuY29uc3QgQ0hBUl9HUkVBVEVSX1RIQU4gPSA2MjtcbmNvbnN0IENIQVJfQ09MT04gPSA1ODtcbmNvbnN0IENIQVJfU1BBQ0UgPSAzMjtcbmNvbnN0IENIQVJfVEFCID0gOTtcbmNvbnN0IENIQVJfQ1IgPSAxMztcbmNvbnN0IENIQVJfTEYgPSAxMDtcbmNvbnN0IENIQVJfU0xBU0ggPSA0NztcbmNvbnN0IENIQVJfRVhNQVJLID0gMzM7XG5jb25zdCBDSEFSX1FNQVJLID0gNjM7XG5jb25zdCBDSEFSX0VRVUFMID0gNjE7XG5cbmNvbnN0IFNUQVRFX0xFU1NfVEhBTiA9IDE7XG5jb25zdCBTVEFURV9TSU5HTEVfUVVPVEUgPSAyO1xuY29uc3QgU1RBVEVfRE9VQkxFX1FVT1RFID0gMztcblxuZXhwb3J0IGludGVyZmFjZSBBdHRyaWJ1dGUge1xuICBuYW1lOiBzdHJpbmc7XG4gIG5hbWVzcGFjZTogc3RyaW5nO1xuICBsb2NhbE5hbWU6IHN0cmluZztcbiAgdmFsdWU6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFbGVtZW50IHtcbiAgbmFtZTogc3RyaW5nO1xuICBuYW1lc3BhY2U6IHN0cmluZztcbiAgbG9jYWxOYW1lOiBzdHJpbmc7XG4gIGF0dHJzOiBzdHJpbmc7XG4gIHRleHQ6IHN0cmluZztcbiAgYm9keUluZGV4OiBudW1iZXI7XG4gIGNoaWxkcmVuOiBFbGVtZW50W107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVhtbERlY2xhcmF0aW9uKGJ1ZmZlcjogQnVmZmVyKTogQXR0cmlidXRlW10ge1xuICBjb25zdCBlbmNvZGluZ3M6IEJ1ZmZlckVuY29kaW5nW10gPSBbXCJ1dGYxNmxlXCIsIFwidXRmOFwiLCBcImxhdGluMVwiLCBcImFzY2lpXCJdO1xuICBmb3IgKGNvbnN0IGVuYyBvZiBlbmNvZGluZ3MpIHtcbiAgICBsZXQgc3RyID0gYnVmZmVyLnRvU3RyaW5nKGVuYywgMCwgMTUwKTtcbiAgICBpZiAoc3RyLnN0YXJ0c1dpdGgoXCI8P3htbFwiKSkge1xuICAgICAgc3RyID0gc3RyLnNsaWNlKDAsIHN0ci5pbmRleE9mKFwiPz5cIikpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHBhcnNlQXR0cnMoc3RyLnNsaWNlKDUpKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBJZ25vcmVcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUF0dHJzKHN0cmluZzogc3RyaW5nKTogQXR0cmlidXRlW10ge1xuICBjb25zdCBhdHRyczogQXR0cmlidXRlW10gPSBbXTtcbiAgY29uc3QgbGVuID0gc3RyaW5nLmxlbmd0aDtcblxuICBsZXQgc3RhdGUgPSAwO1xuICBsZXQgbmFtZSA9IFwiXCI7XG4gIGxldCBuYW1lc3BhY2UgPSBcIlwiO1xuICBsZXQgbG9jYWxOYW1lID0gXCJcIjtcbiAgbGV0IGlkeCA9IDA7XG4gIGxldCBjb2xvbklkeCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBjb25zdCBjID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgc3dpdGNoIChjKSB7XG4gICAgICBjYXNlIENIQVJfU0lOR0xFX1FVT1RFOlxuICAgICAgY2FzZSBDSEFSX0RPVUJMRV9RVU9URTpcbiAgICAgICAgaWYgKHN0YXRlID09PSBjKSB7XG4gICAgICAgICAgc3RhdGUgPSAwO1xuICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHN0cmluZy5zbGljZShpZHggKyAxLCBpKTtcbiAgICAgICAgICAgIGNvbnN0IGUgPSB7XG4gICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuICAgICAgICAgICAgICBsb2NhbE5hbWU6IGxvY2FsTmFtZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGF0dHJzLnB1c2goZSk7XG4gICAgICAgICAgICBuYW1lID0gXCJcIjtcbiAgICAgICAgICAgIGlkeCA9IGkgKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZSA9IGM7XG4gICAgICAgICAgaWR4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcblxuICAgICAgY2FzZSBDSEFSX0NPTE9OOlxuICAgICAgICBpZiAoc3RhdGUpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoaWR4ID49IGNvbG9uSWR4KSBjb2xvbklkeCA9IGk7XG4gICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICBjYXNlIENIQVJfRVFVQUw6XG4gICAgICAgIGlmIChzdGF0ZSkgY29udGludWU7XG4gICAgICAgIGlmIChuYW1lKSB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0ICR7aX1gKTtcbiAgICAgICAgbmFtZSA9IHN0cmluZy5zbGljZShpZHgsIGkpLnRyaW0oKTtcbiAgICAgICAgLy8gVE9ETyB2YWxpZGF0ZSBuYW1lXG4gICAgICAgIGlmIChjb2xvbklkeCA+IGlkeCkge1xuICAgICAgICAgIG5hbWVzcGFjZSA9IHN0cmluZy5zbGljZShpZHgsIGNvbG9uSWR4KS50cmltKCk7XG4gICAgICAgICAgbG9jYWxOYW1lID0gc3RyaW5nLnNsaWNlKGNvbG9uSWR4ICsgMSwgaSkudHJpbSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5hbWVzcGFjZSA9IFwiXCI7XG4gICAgICAgICAgbG9jYWxOYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChuYW1lKSB0aHJvdyBuZXcgRXJyb3IoYEF0dHJpYnV0ZSBtdXN0IGhhdmUgdmFsdWUgYXQgJHtpZHh9YCk7XG5cbiAgY29uc3QgdGFpbCA9IHN0cmluZy5zbGljZShpZHgpO1xuICBpZiAodGFpbC50cmltKCkpIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBzdHJpbmcgYXQgJHtsZW4gLSB0YWlsLmxlbmd0aH1gKTtcblxuICByZXR1cm4gYXR0cnM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVFbnRpdGllcyhzdHJpbmc6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvJlswLTlhLXojXSs7L2dpLCAobWF0Y2gpID0+IHtcbiAgICBzd2l0Y2ggKG1hdGNoKSB7XG4gICAgICBjYXNlIFwiJnF1b3Q7XCI6XG4gICAgICAgIHJldHVybiAnXCInO1xuXG4gICAgICBjYXNlIFwiJmFtcDtcIjpcbiAgICAgICAgcmV0dXJuIFwiJlwiO1xuXG4gICAgICBjYXNlIFwiJmFwb3M7XCI6XG4gICAgICAgIHJldHVybiBcIidcIjtcblxuICAgICAgY2FzZSBcIiZsdDtcIjpcbiAgICAgICAgcmV0dXJuIFwiPFwiO1xuXG4gICAgICBjYXNlIFwiJmd0O1wiOlxuICAgICAgICByZXR1cm4gXCI+XCI7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChtYXRjaC5zdGFydHNXaXRoKFwiJiN4XCIpKSB7XG4gICAgICAgICAgY29uc3Qgc3RyID0gbWF0Y2guc2xpY2UoMywgLTEpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgY29uc3QgbiA9IHBhcnNlSW50KHN0ciwgMTYpO1xuICAgICAgICAgIGlmIChzdHIuZW5kc1dpdGgobi50b1N0cmluZygxNikpKSByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShuKTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaC5zdGFydHNXaXRoKFwiJiNcIikpIHtcbiAgICAgICAgICBjb25zdCBzdHIgPSBtYXRjaC5zbGljZSgyLCAtMSk7XG4gICAgICAgICAgY29uc3QgbiA9IHBhcnNlSW50KHN0cik7XG4gICAgICAgICAgaWYgKHN0ci5lbmRzV2l0aChuLnRvU3RyaW5nKCkpKSByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF0Y2g7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlRW50aXRpZXMoc3RyaW5nOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBlbnRpdGllcyA9IHtcbiAgICBcIiZcIjogXCImYW1wO1wiLFxuICAgICdcIic6IFwiJnF1b3Q7XCIsXG4gICAgXCInXCI6IFwiJmFwb3M7XCIsXG4gICAgXCI8XCI6IFwiJmx0O1wiLFxuICAgIFwiPlwiOiBcIiZndDtcIixcbiAgfTtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bJlwiJzw+XS9nLCAobSkgPT4gZW50aXRpZXNbbV0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VYbWwoc3RyaW5nOiBzdHJpbmcpOiBFbGVtZW50IHtcbiAgY29uc3QgbGVuID0gc3RyaW5nLmxlbmd0aDtcbiAgbGV0IHN0YXRlMSA9IDA7XG4gIGxldCBzdGF0ZTFJbmRleCA9IDA7XG4gIGxldCBzdGF0ZTIgPSAwO1xuICBsZXQgc3RhdGUySW5kZXggPSAwO1xuXG4gIGNvbnN0IHJvb3Q6IEVsZW1lbnQgPSB7XG4gICAgbmFtZTogXCJyb290XCIsXG4gICAgbmFtZXNwYWNlOiBcIlwiLFxuICAgIGxvY2FsTmFtZTogXCJyb290XCIsXG4gICAgYXR0cnM6IFwiXCIsXG4gICAgdGV4dDogXCJcIixcbiAgICBib2R5SW5kZXg6IDAsXG4gICAgY2hpbGRyZW46IFtdLFxuICB9O1xuXG4gIGNvbnN0IHN0YWNrOiBFbGVtZW50W10gPSBbcm9vdF07XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHN3aXRjaCAoc3RyaW5nLmNoYXJDb2RlQXQoaSkpIHtcbiAgICAgIGNhc2UgQ0hBUl9TSU5HTEVfUVVPVEU6XG4gICAgICAgIHN3aXRjaCAoc3RhdGUxICYgMHhmZikge1xuICAgICAgICAgIGNhc2UgU1RBVEVfU0lOR0xFX1FVT1RFOlxuICAgICAgICAgICAgc3RhdGUxID0gc3RhdGUyO1xuICAgICAgICAgICAgc3RhdGUxSW5kZXggPSBzdGF0ZTJJbmRleDtcbiAgICAgICAgICAgIHN0YXRlMiA9IDA7XG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgIGNhc2UgU1RBVEVfTEVTU19USEFOOlxuICAgICAgICAgICAgc3RhdGUyID0gc3RhdGUxO1xuICAgICAgICAgICAgc3RhdGUySW5kZXggPSBzdGF0ZTFJbmRleDtcbiAgICAgICAgICAgIHN0YXRlMSA9IFNUQVRFX1NJTkdMRV9RVU9URTtcbiAgICAgICAgICAgIHN0YXRlMUluZGV4ID0gaTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICBjYXNlIENIQVJfRE9VQkxFX1FVT1RFOlxuICAgICAgICBzd2l0Y2ggKHN0YXRlMSAmIDB4ZmYpIHtcbiAgICAgICAgICBjYXNlIFNUQVRFX0RPVUJMRV9RVU9URTpcbiAgICAgICAgICAgIHN0YXRlMSA9IHN0YXRlMjtcbiAgICAgICAgICAgIHN0YXRlMUluZGV4ID0gc3RhdGUySW5kZXg7XG4gICAgICAgICAgICBzdGF0ZTIgPSAwO1xuICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICBjYXNlIFNUQVRFX0xFU1NfVEhBTjpcbiAgICAgICAgICAgIHN0YXRlMiA9IHN0YXRlMTtcbiAgICAgICAgICAgIHN0YXRlMkluZGV4ID0gc3RhdGUxSW5kZXg7XG4gICAgICAgICAgICBzdGF0ZTEgPSBTVEFURV9ET1VCTEVfUVVPVEU7XG4gICAgICAgICAgICBzdGF0ZTFJbmRleCA9IGk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcblxuICAgICAgY2FzZSBDSEFSX0xFU1NfVEhBTjpcbiAgICAgICAgaWYgKChzdGF0ZTEgJiAweGZmKSA9PT0gMCkge1xuICAgICAgICAgIHN0YXRlMiA9IHN0YXRlMTtcbiAgICAgICAgICBzdGF0ZTJJbmRleCA9IHN0YXRlMUluZGV4O1xuICAgICAgICAgIHN0YXRlMSA9IFNUQVRFX0xFU1NfVEhBTjtcbiAgICAgICAgICBzdGF0ZTFJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG5cbiAgICAgIGNhc2UgQ0hBUl9DT0xPTjpcbiAgICAgICAgaWYgKChzdGF0ZTEgJiAweGZmKSA9PT0gU1RBVEVfTEVTU19USEFOKSB7XG4gICAgICAgICAgY29uc3QgY29sb25JbmRleCA9IChzdGF0ZTEgPj4gOCkgJiAweGZmO1xuICAgICAgICAgIGlmIChjb2xvbkluZGV4ID09PSAwKSBzdGF0ZTEgXj0gKChpIC0gc3RhdGUxSW5kZXgpICYgMHhmZikgPDwgODtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcblxuICAgICAgY2FzZSBDSEFSX1NQQUNFOlxuICAgICAgY2FzZSBDSEFSX1RBQjpcbiAgICAgIGNhc2UgQ0hBUl9DUjpcbiAgICAgIGNhc2UgQ0hBUl9MRjpcbiAgICAgICAgaWYgKChzdGF0ZTEgJiAweGZmKSA9PT0gU1RBVEVfTEVTU19USEFOKSB7XG4gICAgICAgICAgY29uc3Qgd3NJbmRleCA9IChzdGF0ZTEgPj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBpZiAod3NJbmRleCA9PT0gMCkgc3RhdGUxIF49ICgoaSAtIHN0YXRlMUluZGV4KSAmIDB4ZmYpIDw8IDE2O1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICBjYXNlIENIQVJfR1JFQVRFUl9USEFOOlxuICAgICAgICBpZiAoKHN0YXRlMSAmIDB4ZmYpID09PSBTVEFURV9MRVNTX1RIQU4pIHtcbiAgICAgICAgICBjb25zdCBzZWNvbmRDaGFyID0gc3RyaW5nLmNoYXJDb2RlQXQoc3RhdGUxSW5kZXggKyAxKTtcbiAgICAgICAgICBjb25zdCB3c0luZGV4OiBudW1iZXIgPSAoc3RhdGUxID4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgbGV0IG5hbWU6IHN0cmluZyxcbiAgICAgICAgICAgIGNvbG9uSW5kZXg6IG51bWJlcixcbiAgICAgICAgICAgIGU6IEVsZW1lbnQsXG4gICAgICAgICAgICBwYXJlbnQ6IEVsZW1lbnQsXG4gICAgICAgICAgICBzZWxmQ2xvc2luZzogbnVtYmVyLFxuICAgICAgICAgICAgbG9jYWxOYW1lOiBzdHJpbmcsXG4gICAgICAgICAgICBuYW1lc3BhY2U6IHN0cmluZztcblxuICAgICAgICAgIHN3aXRjaCAoc2Vjb25kQ2hhcikge1xuICAgICAgICAgICAgY2FzZSBDSEFSX1NMQVNIOlxuICAgICAgICAgICAgICBlID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgIG5hbWUgPVxuICAgICAgICAgICAgICAgIHdzSW5kZXggPT09IDBcbiAgICAgICAgICAgICAgICAgID8gc3RyaW5nLnNsaWNlKHN0YXRlMUluZGV4ICsgMiwgaSlcbiAgICAgICAgICAgICAgICAgIDogc3RyaW5nLnNsaWNlKHN0YXRlMUluZGV4ICsgMiwgc3RhdGUxSW5kZXggKyB3c0luZGV4KTtcbiAgICAgICAgICAgICAgaWYgKGUubmFtZSAhPT0gbmFtZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVubWF0Y2hlZCBjbG9zaW5nIHRhZyBhdCAke2l9YCk7XG4gICAgICAgICAgICAgIGlmICghZS5jaGlsZHJlbi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZS50ZXh0ID0gc3RyaW5nLnNsaWNlKGUuYm9keUluZGV4LCBzdGF0ZTFJbmRleCk7XG4gICAgICAgICAgICAgIHN0YXRlMSA9IHN0YXRlMjtcbiAgICAgICAgICAgICAgc3RhdGUxSW5kZXggPSBzdGF0ZTJJbmRleDtcbiAgICAgICAgICAgICAgc3RhdGUyID0gMDtcbiAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIGNhc2UgQ0hBUl9FWE1BUks6XG4gICAgICAgICAgICAgIGlmIChzdHJpbmcuc3RhcnRzV2l0aChcIiFbQ0RBVEFbXCIsIHN0YXRlMUluZGV4ICsgMSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyaW5nLmVuZHNXaXRoKFwiXV1cIiwgaSkpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENEQVRBIG5vZGVzIGFyZSBub3Qgc3VwcG9ydGVkIGF0ICR7aX1gKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpbmcuc3RhcnRzV2l0aChcIiEtLVwiLCBzdGF0ZTFJbmRleCArIDEpKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29tbWVudCBub2RlLCBpZ25vcmVcbiAgICAgICAgICAgICAgICBpZiAoc3RyaW5nLmVuZHNXaXRoKFwiLS1cIiwgaSkpIHtcbiAgICAgICAgICAgICAgICAgIHN0YXRlMSA9IHN0YXRlMjtcbiAgICAgICAgICAgICAgICAgIHN0YXRlMUluZGV4ID0gc3RhdGUySW5kZXg7XG4gICAgICAgICAgICAgICAgICBzdGF0ZTIgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgY2FzZSBDSEFSX1FNQVJLOlxuICAgICAgICAgICAgICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoaSAtIDEpID09PSBDSEFSX1FNQVJLKSB7XG4gICAgICAgICAgICAgICAgLy8gWE1MIGRlY2xhcmF0aW9uIG5vZGUsIGlnbm9yZVxuICAgICAgICAgICAgICAgIHN0YXRlMSA9IHN0YXRlMjtcbiAgICAgICAgICAgICAgICBzdGF0ZTFJbmRleCA9IHN0YXRlMkluZGV4O1xuICAgICAgICAgICAgICAgIHN0YXRlMiA9IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHNlbGZDbG9zaW5nID0gKyhzdHJpbmcuY2hhckNvZGVBdChpIC0gMSkgPT09IENIQVJfU0xBU0gpO1xuICAgICAgICAgICAgICBwYXJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgY29sb25JbmRleCA9IChzdGF0ZTEgPj4gOCkgJiAweGZmO1xuXG4gICAgICAgICAgICAgIG5hbWUgPVxuICAgICAgICAgICAgICAgIHdzSW5kZXggPT09IDBcbiAgICAgICAgICAgICAgICAgID8gc3RyaW5nLnNsaWNlKHN0YXRlMUluZGV4ICsgMSwgaSAtIHNlbGZDbG9zaW5nKVxuICAgICAgICAgICAgICAgICAgOiBzdHJpbmcuc2xpY2Uoc3RhdGUxSW5kZXggKyAxLCBzdGF0ZTFJbmRleCArIHdzSW5kZXgpO1xuICAgICAgICAgICAgICBpZiAoY29sb25JbmRleCAmJiAoIXdzSW5kZXggfHwgY29sb25JbmRleCA8IHdzSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxOYW1lID0gbmFtZS5zbGljZShjb2xvbkluZGV4KTtcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2UgPSBuYW1lLnNsaWNlKDAsIGNvbG9uSW5kZXggLSAxKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2NhbE5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgICAgIG5hbWVzcGFjZSA9IFwiXCI7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBlID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgbG9jYWxOYW1lOiBsb2NhbE5hbWUsXG4gICAgICAgICAgICAgICAgYXR0cnM6IHdzSW5kZXhcbiAgICAgICAgICAgICAgICAgID8gc3RyaW5nLnNsaWNlKHN0YXRlMUluZGV4ICsgd3NJbmRleCArIDEsIGkgLSBzZWxmQ2xvc2luZylcbiAgICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgICAgIGJvZHlJbmRleDogaSArIDEsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaChlKTtcbiAgICAgICAgICAgICAgaWYgKCFzZWxmQ2xvc2luZykgc3RhY2sucHVzaChlKTtcblxuICAgICAgICAgICAgICBzdGF0ZTEgPSBzdGF0ZTI7XG4gICAgICAgICAgICAgIHN0YXRlMUluZGV4ID0gc3RhdGUySW5kZXg7XG4gICAgICAgICAgICAgIHN0YXRlMiA9IDA7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdGUxKSB0aHJvdyBuZXcgRXJyb3IoYFVuY2xvc2VkIHRva2VuIGF0ICR7c3RhdGUxSW5kZXh9YCk7XG5cbiAgaWYgKHN0YWNrLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCBlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmNsb3NlZCBYTUwgZWxlbWVudCBhdCAke2UuYm9keUluZGV4fWApO1xuICB9XG5cbiAgaWYgKCFyb290LmNoaWxkcmVuLmxlbmd0aCkgcm9vdC50ZXh0ID0gc3RyaW5nO1xuICByZXR1cm4gcm9vdDtcbn1cbiJdfQ==